{"version":3,"sources":["MMKV.ts"],"names":["onValueChangedListeners","Map","MMKV","constructor","configuration","id","nativeInstance","functionCache","has","set","get","getFunctionFromCache","functionName","onValuesAboutToChange","keys","length","setImmediate","key","listener","value","func","getBoolean","getString","getNumber","contains","delete","getAllKeys","clearAll","addOnValueChangedListener","onValueChanged","push","remove","index","indexOf","splice"],"mappings":"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","sourcesContent":["import { unstable_batchedUpdates } from 'react-native';\nimport { createMMKV } from './createMMKV';\n\ninterface Listener {\n  remove: () => void;\n}\n\n/**\n * Used for configuration of a single MMKV instance.\n */\nexport interface MMKVConfiguration {\n  /**\n   * The MMKV instance's ID. If you want to use multiple instances, make sure to use different IDs!\n   *\n   * @example\n   * ```ts\n   * const userStorage = new MMKV({ id: `user-${userId}-storage` })\n   * const globalStorage = new MMKV({ id: 'global-app-storage' })\n   * ```\n   *\n   * @default 'mmkv.default'\n   */\n  id: string;\n  /**\n   * The MMKV instance's root path. By default, MMKV stores file inside `$(Documents)/mmkv/`. You can customize MMKV's root directory on MMKV initialization:\n   *\n   * @example\n   * ```ts\n   * const temporaryStorage = new MMKV({ path: '/tmp/' })\n   * ```\n   */\n  path?: string;\n  /**\n   * The MMKV instance's encryption/decryption key. By default, MMKV stores all key-values in plain text on file, relying on iOS's sandbox to make sure the file is encrypted. Should you worry about information leaking, you can choose to encrypt MMKV.\n   *\n   * @example\n   * ```ts\n   * const secureStorage = new MMKV({ encryptionKey: 'my-encryption-key!' })\n   * ```\n   */\n  encryptionKey?: string;\n}\n\n/**\n * Represents a single MMKV instance.\n */\ninterface MMKVInterface {\n  /**\n   * Set a value for the given `key`.\n   */\n  set: (key: string, value: boolean | string | number) => void;\n  /**\n   * Get a boolean value for the given `key`.\n   *\n   * @default false\n   */\n  getBoolean: (key: string) => boolean;\n  /**\n   * Get a string value for the given `key`.\n   *\n   * @default undefined\n   */\n  getString: (key: string) => string | undefined;\n  /**\n   * Get a number value for the given `key`.\n   *\n   * @default 0\n   */\n  getNumber: (key: string) => number;\n  /**\n   * Checks whether the given `key` is being stored in this MMKV instance.\n   */\n  contains: (key: string) => boolean;\n  /**\n   * Delete the given `key`.\n   */\n  delete: (key: string) => void;\n  /**\n   * Get all keys.\n   *\n   * @default []\n   */\n  getAllKeys: () => string[];\n  /**\n   * Delete all keys.\n   */\n  clearAll: () => void;\n  /**\n   * Adds a value changed listener.\n   */\n  addOnValueChangedListener: (\n    onValueChanged: (key: string) => void\n  ) => Listener;\n}\n\nexport type NativeMMKV = Pick<\n  MMKVInterface,\n  | 'clearAll'\n  | 'contains'\n  | 'delete'\n  | 'getAllKeys'\n  | 'getBoolean'\n  | 'getNumber'\n  | 'getString'\n  | 'set'\n>;\n\nconst onValueChangedListeners = new Map<string, ((key: string) => void)[]>();\n\n/**\n * A single MMKV instance.\n */\nexport class MMKV implements MMKVInterface {\n  private nativeInstance: NativeMMKV;\n  private functionCache: Partial<NativeMMKV>;\n  private id: string;\n\n  /**\n   * Creates a new MMKV instance with the given Configuration.\n   * If no custom `id` is supplied, `'default'` will be used.\n   */\n  constructor(configuration: MMKVConfiguration = { id: 'mmkv.default' }) {\n    this.id = configuration.id;\n    this.nativeInstance = createMMKV(configuration);\n    this.functionCache = {};\n  }\n\n  private get onValueChangedListeners() {\n    if (!onValueChangedListeners.has(this.id)) {\n      onValueChangedListeners.set(this.id, []);\n    }\n    return onValueChangedListeners.get(this.id)!;\n  }\n\n  private getFunctionFromCache<T extends keyof NativeMMKV>(\n    functionName: T\n  ): NativeMMKV[T] {\n    if (this.functionCache[functionName] == null) {\n      this.functionCache[functionName] = this.nativeInstance[functionName];\n    }\n    return this.functionCache[functionName] as NativeMMKV[T];\n  }\n\n  private onValuesAboutToChange(keys: string[]) {\n    if (this.onValueChangedListeners.length === 0) return;\n\n    setImmediate(() => {\n      unstable_batchedUpdates(() => {\n        for (const key of keys) {\n          for (const listener of this.onValueChangedListeners) {\n            listener(key);\n          }\n        }\n      });\n    });\n  }\n\n  set(key: string, value: boolean | string | number): void {\n    this.onValuesAboutToChange([key]);\n\n    const func = this.getFunctionFromCache('set');\n    return func(key, value);\n  }\n  getBoolean(key: string): boolean {\n    const func = this.getFunctionFromCache('getBoolean');\n    return func(key);\n  }\n  getString(key: string): string | undefined {\n    const func = this.getFunctionFromCache('getString');\n    return func(key);\n  }\n  getNumber(key: string): number {\n    const func = this.getFunctionFromCache('getNumber');\n    return func(key);\n  }\n  contains(key: string): boolean {\n    const func = this.getFunctionFromCache('contains');\n    return func(key);\n  }\n  delete(key: string): void {\n    this.onValuesAboutToChange([key]);\n\n    const func = this.getFunctionFromCache('delete');\n    return func(key);\n  }\n  getAllKeys(): string[] {\n    const func = this.getFunctionFromCache('getAllKeys');\n    return func();\n  }\n  clearAll(): void {\n    const keys = this.getAllKeys();\n    this.onValuesAboutToChange(keys);\n\n    const func = this.getFunctionFromCache('clearAll');\n    return func();\n  }\n\n  addOnValueChangedListener(onValueChanged: (key: string) => void): Listener {\n    this.onValueChangedListeners.push(onValueChanged);\n\n    return {\n      remove: () => {\n        const index = this.onValueChangedListeners.indexOf(onValueChanged);\n        if (index !== -1) {\n          this.onValueChangedListeners.splice(index, 1);\n        }\n      },\n    };\n  }\n}\n"]}